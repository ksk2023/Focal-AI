<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#667eea">
    <title>AI æ‹ç…§åŠ©æ‰‹</title>

    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/svg+xml" href="icon-192.svg">

    <!-- çº¯è§†è§‰æ¨¡å¼ï¼Œæ— éœ€ MediaPipe -->

    <style>
        :root {
            --app-bg: #000000;
            --panel-bg: rgba(20, 20, 20, 0.85);
            --accent-color: #ffd60a;
            /* iOS Yellow */
            --text-primary: #ffffff;
            --text-secondary: rgba(255, 255, 255, 0.6);
            --safe-area-top: env(safe-area-inset-top, 20px);
            --safe-area-bottom: env(safe-area-inset-bottom, 20px);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            font-family: -apple-system, BlinkMacSystemFont, "SF Pro Text", "Helvetica Neue", sans-serif;
        }

        /* Full Screen Mobile App */
        body {
            background: #000;
            color: var(--text-primary);
            width: 100%;
            height: 100vh;
            height: 100dvh;
            /* Dynamic Viewport Height */
            overflow: hidden;
            display: flex;
            flex-direction: column;
            margin: 0;
            padding: 0;
        }

        .app {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            background: #000;
            position: relative;
            max-width: 600px;
            /* Limit width on desktops */
            margin: 0 auto;
            /* Center on desktop */
            box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
            /* Shadow on desktop */
        }

        @media (max-width: 600px) {
            .app {
                box-shadow: none;
                max-width: 100%;
            }
        }

        /* é¡¶éƒ¨çŠ¶æ€æ åŒºåŸŸ */
        .top-bar {
            height: 60px;
            padding-top: var(--safe-area-top);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-left: 20px;
            padding-right: 20px;
            z-index: 10;
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.8), transparent);
        }

        /* ä¸»å–æ™¯å™¨ - å æ®ä¸­é—´å¤§éƒ¨åˆ† */
        .viewfinder {
            flex: 1;
            position: relative;
            background: #000;
            overflow: hidden;
            border-radius: 20px;
            /* è½»å¾®åœ†è§’ */
            margin: 0 10px;
        }

        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            /* é•œåƒ */
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* åº•éƒ¨æ§åˆ¶åŒº */
        .controls-area {
            height: 160px;
            padding-bottom: var(--safe-area-bottom);
            background: #000;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
        }

        /* æ¨¡å¼é€‰æ‹©å™¨ (Photo/Video/Smart) */
        .mode-selector {
            display: flex;
            justify-content: center;
            gap: 24px;
            margin-bottom: 20px;
        }

        .mode-item {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            padding: 4px 8px;
            border-radius: 12px;
            transition: all 0.3s;
            cursor: pointer;
            letter-spacing: 0.5px;
        }

        .mode-item.active {
            color: #ffd60a;
            background: rgba(255, 214, 10, 0.15);
        }

        /* åº•éƒ¨æŒ‰é’®æ  */
        .action-bar {
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 0 40px 30px;
        }

        /* ç›¸å†Œé¢„è§ˆæŒ‰é’® */
        .btn-gallery {
            width: 48px;
            height: 48px;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            overflow: hidden;
            border: 1px solid rgba(255, 255, 255, 0.2);
            position: relative;
        }

        .btn-gallery img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* iOS å¿«é—¨æŒ‰é’® */
        .shutter-btn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 4px solid #fff;
            padding: 3px;
            background: transparent;
            cursor: pointer;
            transition: transform 0.1s;
        }

        .shutter-inner {
            width: 100%;
            height: 100%;
            background: #fff;
            border-radius: 50%;
            transition: all 0.2s;
        }

        .shutter-btn:active {
            transform: scale(0.95);
        }

        .shutter-btn:active .shutter-inner {
            transform: scale(0.9);
            background: #ccc;
        }

        /* ç¿»è½¬/è®¾ç½®æŒ‰é’® */
        .btn-icon {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            border: none;
            font-size: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(10px);
            cursor: pointer;
        }

        /* AI çµæ„ŸçŠ¶æ€æ‚¬æµ®èƒ¶å›Š */
        .ai-capsule {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-radius: 30px;
            padding: 8px 16px 8px 10px;
            display: flex;
            align-items: center;
            gap: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 100;
            transition: all 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
        }

        .ai-capsule.active {
            background: rgba(10, 132, 255, 0.85);
            /* iOS Blue */
            box-shadow: 0 8px 32px rgba(10, 132, 255, 0.3);
        }

        .ai-icon-anim {
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }

        .ai-text {
            font-size: 14px;
            font-weight: 500;
            color: #fff;
        }

        .ai-controls-float {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            z-index: 50;
        }

        .glass-btn {
            background: rgba(20, 20, 20, 0.6);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
        }

        /* éº¦å…‹é£æŒ‰é’® */
        .btn-mic {
            width: 56px;
            height: 56px;
            background: linear-gradient(135deg, #00b894, #00cec9);
            color: #fff;
            font-size: 24px;
            box-shadow: 0 8px 25px rgba(0, 184, 148, 0.4);
            transition: all 0.3s ease;
        }

        .btn-mic.recording {
            background: linear-gradient(135deg, #ff6b6b, #ee5a5a);
            animation: pulse-recording 0.8s infinite;
        }

        /* VAD çŠ¶æ€æŒ‡ç¤ºå™¨ */
        .vad-indicator {
            position: absolute;
            top: 90px;
            right: 16px;
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: rgba(0, 184, 148, 0.3);
            border-radius: 20px;
            font-size: 12px;
            color: #00ff78;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .vad-indicator.active {
            opacity: 1;
        }

        .vad-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #00ff78;
            animation: vad-blink 1s infinite;
        }

        /* MCP çŠ¶æ€æŒ‡ç¤ºå™¨ */
        .mcp-indicator {
            position: absolute;
            top: 90px;
            right: 50px;
            font-size: 16px;
            opacity: 0.5;
            transition: opacity 0.3s;
        }

        .mcp-indicator.active {
            opacity: 1;
        }

        @keyframes vad-blink {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.3;
            }
        }

        /* ç”¨æˆ·æ‰“æ–­æç¤º */
        .interrupt-toast {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 107, 107, 0.95);
            color: #fff;
            padding: 16px 32px;
            border-radius: 24px;
            font-size: 16px;
            font-weight: 500;
            display: none;
            animation: interrupt-pop 0.3s ease-out;
            z-index: 150;
        }

        .interrupt-toast.show {
            display: block;
        }

        @keyframes interrupt-pop {
            0% {
                transform: translate(-50%, -50%) scale(0.8);
                opacity: 0;
            }

            100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        @keyframes pulse-recording {

            0%,
            100% {
                transform: scale(1);
                box-shadow: 0 8px 25px rgba(255, 107, 107, 0.4);
            }

            50% {
                transform: scale(1.1);
                box-shadow: 0 8px 35px rgba(255, 107, 107, 0.8);
            }
        }

        /* çµæ„Ÿæ‹æ‘„æŒ‰é’® */
        .btn-inspiration {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            font-size: 14px;
            border-radius: 25px;
            transition: all 0.3s ease;
        }

        .btn-inspiration.active {
            background: linear-gradient(135deg, #00d9ff, #00b894);
            border-color: transparent;
            box-shadow: 0 4px 20px rgba(0, 217, 255, 0.4);
        }

        .btn-inspiration .inspiration-icon {
            font-size: 18px;
        }

        /* AI æ§åˆ¶æ  */
        .ai-controls {
            position: absolute;
            bottom: 100px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 15px 20px;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(10px);
        }

        .ai-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.9);
            font-size: 12px;
            cursor: pointer;
            padding: 8px 16px;
        }

        .ai-btn span:first-child {
            font-size: 24px;
        }

        .ai-btn:active {
            transform: scale(0.95);
        }

        /* å§¿åŠ¿ä¸‹æ‹‰é€‰æ‹©å™¨ */
        .pose-dropdown {
            padding: 10px 16px;
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            color: #fff;
            font-size: 14px;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' fill='white' viewBox='0 0 16 16'%3E%3Cpath d='M8 11L3 6h10l-5 5z'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 12px center;
            padding-right: 35px;
        }

        .pose-dropdown option {
            background: #1a1a2e;
            color: #fff;
        }

        /* AI çŠ¶æ€æ  */
        .ai-status-bar {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 20px;
            background: linear-gradient(135deg, rgba(0, 217, 255, 0.9), rgba(0, 184, 148, 0.9));
            border-radius: 20px;
            color: #fff;
            font-size: 14px;
            font-weight: 500;
            box-shadow: 0 4px 20px rgba(0, 217, 255, 0.3);
            z-index: 100;
            opacity: 1;
            transition: opacity 0.8s ease-out;
        }

        .ai-status-bar.fade-out {
            opacity: 0;
        }

        .ai-status-icon {
            font-size: 18px;
        }

        /* ç…§ç‰‡é¢„è§ˆ */
        .photo-preview {
            position: absolute;
            bottom: 140px;
            left: 32px;
            width: 70px;
            height: 70px;
            border-radius: 16px;
            overflow: hidden;
            border: 3px solid #fff;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
            display: none;
        }

        .photo-preview img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* Settings Action Sheet */
        .settings-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.4);
            z-index: 200;
            display: none;
            backdrop-filter: blur(2px);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .settings-overlay.show {
            display: block;
            opacity: 1;
        }

        .settings-panel {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            background: rgba(30, 30, 30, 0.85);
            /* Glass dark */
            backdrop-filter: blur(25px);
            -webkit-backdrop-filter: blur(25px);
            border-radius: 20px;
            padding: 24px 20px 40px;
            transform: translateY(110%);
            transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1);
            color: #fff;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .settings-overlay.show .settings-panel {
            transform: translateY(0);
        }

        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
        }

        .settings-header h2 {
            font-size: 17px;
            font-weight: 600;
            color: #fff;
        }

        .settings-group {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 16px;
        }

        .toggle-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 14px 16px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .toggle-item:last-child {
            border-bottom: none;
        }

        .toggle-item span {
            font-size: 16px;
        }

        /* iOS Toggle Switch */
        input[type="checkbox"] {
            -webkit-appearance: none;
            width: 50px;
            height: 30px;
            background: rgba(120, 120, 128, 0.32);
            border-radius: 15px;
            position: relative;
            cursor: pointer;
            transition: 0.3s;
        }

        input[type="checkbox"]:checked {
            background: #34c759;
            /* iOS Green */
        }

        input[type="checkbox"]::after {
            content: '';
            position: absolute;
            width: 26px;
            height: 26px;
            border-radius: 50%;
            background: #fff;
            top: 2px;
            left: 2px;
            transition: 0.3s;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.15);
        }

        input[type="checkbox"]:checked::after {
            transform: translateX(20px);
        }

        .setting-item {
            padding: 16px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 12px;
        }

        .setting-item label {
            display: block;
            margin-bottom: 12px;
            font-size: 14px;
            opacity: 0.8;
        }

        input[type="range"] {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 2px;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #fff;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }

        /* åŠ è½½çŠ¶æ€ */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 16px;
            z-index: 200;
        }

        .loading.hidden {
            display: none;
        }

        .loading p {
            color: #fff;
            font-size: 14px;
            margin: 0;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top-color: #ffd60a;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }

        /* AI åˆ†æä¸­çŠ¶æ€ */
        .ai-analyzing {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 10px 20px;
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .ai-analyzing.active {
            opacity: 1;
        }

        .ai-analyzing .analyzing-dot {
            width: 8px;
            height: 8px;
            background: #ffd60a;
            border-radius: 50%;
            animation: pulse-dot 1s infinite;
        }

        .ai-analyzing .analyzing-text {
            color: #fff;
            font-size: 14px;
        }

        @keyframes pulse-dot {

            0%,
            100% {
                opacity: 1;
                transform: scale(1);
            }

            50% {
                opacity: 0.5;
                transform: scale(0.8);
            }
        }

        /* å˜ç„¦æ§åˆ¶ */
        .zoom-controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            z-index: 20;
            background: rgba(0, 0, 0, 0.3);
            padding: 4px;
            border-radius: 20px;
            backdrop-filter: blur(4px);
        }

        .zoom-btn {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: transparent;
            color: #fff;
            font-size: 12px;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none;
            transition: all 0.2s;
        }

        .zoom-btn.active {
            background: rgba(255, 255, 255, 0.2);
            color: #ffd60a;
            transform: scale(1.1);
            font-weight: 800;
        }
    </style>
</head>

<body>
    <div class="app">
        <!-- é¡¶éƒ¨çŠ¶æ€æ  -->
        <div class="top-bar" style="position: relative; justify-content: flex-end;">

            <!-- çµæ„Ÿæ¨¡å¼åŠ¨æ€å²› (ç»å¯¹å±…ä¸­) -->
            <div
                style="position: absolute; left: 50%; transform: translateX(-50%); display: flex; align-items: center; gap: 8px; z-index: 20;">
                <div class="ai-capsule" id="aiCapsule" onclick="toggleInspirationMode()">
                    <span class="ai-icon-anim" id="aiIcon">âœ¨</span>
                    <span class="ai-text" id="aiStatusText">AI åŠ©æ‰‹</span>
                </div>

                <div class="vad-indicator" id="vadIndicator"
                    style="position:static; padding:0; background:none; opacity:0; transition:opacity 0.3s;">
                    <span class="vad-dot" style="background:#34c759;"></span>
                </div>

                <!-- MCP çŠ¶æ€æŒ‡ç¤ºå™¨ -->
                <div class="mcp-indicator" id="mcpIndicator" title="MCP å›¾ç‰‡ç†è§£" style="position: static; opacity: 0.5;">
                    ğŸ”—
                </div>
            </div>

            <!-- è®¾ç½®æŒ‰é’® (å³ä¸Šè§’) -->
            <button class="btn-icon" onclick="toggleSettings()">
                <svg width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                    <circle cx="12" cy="12" r="3"></circle>
                    <path
                        d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z">
                    </path>
                </svg>
            </button>
        </div>

        <!-- ä¸»å–æ™¯å™¨ -->
        <div class="viewfinder">
            <video id="video" playsinline autoplay></video>
            <canvas id="canvas"></canvas>

            <!-- åˆ†æ•°å’Œåé¦ˆ -->
            <div class="score-card" id="scoreCard" style="display: none;">
                <div class="value" id="scoreValue">0%</div>
            </div>

            <!-- æ‚¬æµ®çš„ AI æ§åˆ¶æŒ‰é’® (çµæ„Ÿæ¨¡å¼ä¸‹æ˜¾ç¤º) -->
            <div class="ai-controls-float" id="aiControls" style="display: none;">
                <div class="glass-btn" onclick="toggleMicrophone()" id="micBtnBox">
                    <span id="micIcon">ğŸ¤</span> <span id="micText">è¯­éŸ³</span>
                </div>
                <div class="glass-btn" style="padding: 0;">
                    <select class="pose-dropdown" id="poseDropdown" onchange="changePose(this.value)"
                        style="background:transparent; border:none; color:white; padding: 8px 16px; font-size:13px;">
                        <optgroup label="ğŸ“± è‡ªæ‹">
                            <option value="selfie_smile">ğŸ˜Š å¾®ç¬‘è‡ªæ‹</option>
                            <option value="selfie_peace">âœŒï¸ æ¯”è€¶è‡ªæ‹</option>
                            <option value="selfie_cute">ğŸ¥° å¯çˆ±å˜Ÿå˜´</option>
                            <option value="selfie_cool">ğŸ˜ é…·å¸…ä¾§è„¸</option>
                        </optgroup>
                        <optgroup label="ğŸ“· ä»–æ‹">
                            <option value="standing_casual">ğŸ§ è‡ªç„¶ç«™ç«‹</option>
                            <option value="hands_on_hips">ğŸ™† åŒæ‰‹å‰è…°</option>
                            <option value="photo_pose">ğŸ“¸ æ‹ç…§å§¿åŠ¿</option>
                            <option value="touch_hair">ğŸ’‡ æ’©å¤´å‘</option>
                            <option value="peace_sign">âœŒï¸ æ¯”è€¶</option>
                            <option value="heart_hands">ğŸ’• åŒæ‰‹æ¯”å¿ƒ</option>
                        </optgroup>
                        <optgroup label="ğŸ‘¥ åˆå½±">
                            <option value="group_shoulder">ğŸ¤ æ­è‚©åˆå½±</option>
                            <option value="group_heart">ğŸ’— ç»„åˆæ¯”å¿ƒ</option>
                        </optgroup>
                        <optgroup label="ğŸ’‘ æƒ…ä¾£">
                            <option value="couple_heart">ğŸ’• æƒ…ä¾£æ¯”å¿ƒ</option>
                            <option value="couple_back">ğŸš¶â€â™‚ï¸ æƒ…ä¾£èƒŒå½±</option>
                        </optgroup>
                        <optgroup label="ğŸ° ç¾é£Ÿ">
                            <option value="sitting_coffee">â˜• åç€å–ä¸œè¥¿</option>
                            <option value="chin_on_hand">ğŸ¤” æ‰˜è…®æ€è€ƒ</option>
                            <option value="food_pose">ğŸ• ç¾é£Ÿæ‰“å¡</option>
                        </optgroup>
                        <optgroup label="ğŸŒ³ æˆ·å¤–">
                            <option value="walking_away">ğŸš¶ èƒŒå½±è¡Œèµ°</option>
                            <option value="looking_back">ğŸ”™ å›çœ¸ä¸€ç¬‘</option>
                            <option value="arms_spread">ğŸ™Œ å¼ å¼€åŒè‡‚</option>
                        </optgroup>
                        <optgroup label="ğŸ’ª ä¼‘é—²">
                            <option value="arms_crossed">ğŸ¤— åŒæ‰‹æŠ±èƒ¸</option>
                            <option value="hand_in_pocket">ğŸ™‹ å•æ‰‹æ’å…œ</option>
                            <option value="wave_hello">ğŸ‘‹ æŒ¥æ‰‹æ‰“æ‹›å‘¼</option>
                            <option value="leaning_wall">ğŸ˜Œ å€šé å¢™å£</option>
                            <option value="thumbs_up">ğŸ‘ ç«–å¤§æ‹‡æŒ‡</option>
                        </optgroup>
                    </select>
                </div>
            </div>

            <div id="feedback" class="feedback">ç‚¹å‡» âœ¨ å¼€å¯æ™ºèƒ½æ‹ç…§</div>
            <div class="countdown" id="countdown">3</div>
            <div class="perfect" id="perfectBadge">PERFECT!</div>
            <div class="interrupt-toast" id="interruptToast">ğŸ‘¤ æ‚¨è¯´ï¼Œæˆ‘åœ¨å¬...</div>

            <!-- AI åˆ†æä¸­çŠ¶æ€ -->
            <div class="ai-analyzing" id="aiAnalyzing">
                <span class="analyzing-dot"></span>
                <span class="analyzing-text">AI æ€è€ƒä¸­...</span>
            </div>

            <!-- å˜ç„¦æ§åˆ¶ -->
            <div class="zoom-controls">
                <button class="zoom-btn active" onclick="setZoom(1.0, this)">1x</button>
                <button class="zoom-btn" onclick="setZoom(1.5, this)">1.5</button>
                <button class="zoom-btn" onclick="setZoom(2.0, this)">2x</button>
            </div>

            <div class="loading" id="loading" style="display:flex;">
                <div class="spinner"></div>
                <p>æ­£åœ¨åˆå§‹åŒ– AI å¯¼æ¼”...</p>
            </div>
        </div>

        <!-- åº•éƒ¨æ§åˆ¶åŒº -->
        <div class="controls-area">
            <div class="mode-selector">
                <span class="mode-item">VIDEO</span>
                <span class="mode-item active">PHOTO</span>
                <span class="mode-item" onclick="toggleInspirationMode()">PORTRAIT</span>
            </div>

            <div class="action-bar">
                <!-- ç›¸å†Œ -->
                <div class="btn-gallery" onclick="showGallery()">
                    <div id="galleryPreview" style="width:100%; height:100%; background: #333;">
                        <img id="previewImg" src="" style="width:100%; height:100%; object-fit:cover; display:none;">
                    </div>
                </div>

                <!-- å¿«é—¨ -->
                <button class="shutter-btn" id="captureBtn" onclick="capture()">
                    <div class="shutter-inner"></div>
                </button>

                <!-- ç¿»è½¬ -->
                <button class="btn-icon" onclick="switchCamera()">
                    <svg width="24" height="24" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24">
                        <path
                            d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15">
                        </path>
                    </svg>
                </button>
            </div>
        </div>

        <!-- è®¾ç½®é¢æ¿ (Action Sheet) -->
        <div class="settings-overlay" id="settingsOverlay" onclick="toggleSettings()">
            <div class="settings-panel" onclick="event.stopPropagation()">
                <div class="settings-header">
                    <h2>è®¾ç½®</h2>
                    <button onclick="toggleSettings()"
                        style="background:rgba(120,120,128,0.12); border-radius:50%; width:30px; height:30px; border:none; color:#888;">âœ•</button>
                </div>

                <div class="settings-group">
                    <div class="toggle-item">
                        <span>æ™ºèƒ½æ‰“æ–­ (åŒå·¥æ¨¡å¼)</span>
                        <input type="checkbox" id="enableVAD" onchange="toggleVADSetting(this.checked)">
                    </div>

                    <div class="toggle-item">
                        <span>æ˜¾ç¤ºå¼•å¯¼æ¡†</span>
                        <input type="checkbox" id="showGuide" checked>
                    </div>

                    <div class="toggle-item">
                        <span>æ˜¾ç¤ºéª¨éª¼</span>
                        <input type="checkbox" id="showSkeleton" checked>
                    </div>
                </div>

                <div class="settings-group">
                    <div class="setting-item">
                        <label>è‡ªåŠ¨æ‹ç…§é˜ˆå€¼: <span id="thresholdText">85</span>%</label>
                        <input type="range" id="threshold" min="70" max="100" value="85"
                            oninput="thresholdText.textContent=this.value">
                    </div>
                </div>

                <div class="settings-group">
                    <div class="setting-item">
                        <label>åç«¯åœ°å€</label>
                        <input type="text" id="apiUrlInput" value="" 
                            style="width:100%; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.2); border-radius:8px; padding:8px; color:#fff; font-size:14px;"
                            placeholder="http://192.168.x.x:8000">
                        <button onclick="updateApiUrl()" 
                            style="margin-top:8px; width:100%; background:#ffd60a; border:none; border-radius:8px; padding:8px; color:#000; font-weight:500; cursor:pointer;">
                            è¿æ¥æµ‹è¯•
                        </button>
                        <p id="apiStatus" style="margin-top:8px; font-size:12px; color:rgba(255,255,255,0.6);"></p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let pose, camera;
        let isGuiding = false;
        let score = 0;
        let highScoreTime = null;
        let voiceOn = true;
        let currentPose = 'selfie_smile';
        let poses = {};

        // è¯­éŸ³è¯†åˆ«å˜é‡
        let recognition = null;
        let isRecording = false;

        // ===== çµæ„Ÿæ‹æ‘„æ¨¡å¼ =====
        let inspirationMode = false;  // é»˜è®¤å…³é—­

        // AI åˆ†æç›¸å…³ - è‡ªåŠ¨æ£€æµ‹åç«¯åœ°å€
        function getBackendUrl() {
            // 1. ä¼˜å…ˆä» URL å‚æ•°è·å–ï¼ˆç”¨äºæ‰‹æœºæµ‹è¯•ï¼‰
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.has('api')) {
                return urlParams.get('api');
            }
            // 2. ä¼˜å…ˆä½¿ç”¨å½“å‰ä¸»æœºçš„ 8000 ç«¯å£ï¼ˆè‡ªåŠ¨é€‚é…æ‰‹æœº/ç”µè„‘ï¼‰
            const currentHost = window.location.hostname;
            return `http://${currentHost}:8000`;
        }
        const API_URL = getBackendUrl();
        console.log('ğŸ”— åç«¯åœ°å€:', API_URL);

        let isAnalyzing = false;
        let lastAnalysisTime = 0;
        const ANALYSIS_INTERVAL = 5000;  // 5ç§’é—´éš”ï¼Œé¿å…é¢‘ç¹è¯·æ±‚å¯¼è‡´ 429

        // ===== æ™ºèƒ½è¯­éŸ³äº¤äº’ç³»ç»Ÿ =====
        let conversationMode = false;  // å¯¹è¯æ¨¡å¼ï¼ˆå§‹ç»ˆç›‘å¬ï¼‰
        let lastUserQuery = '';  // ç”¨æˆ·ä¸Šæ¬¡çš„é—®é¢˜
        let aiSpeaking = false;  // AI æ˜¯å¦æ­£åœ¨è¯´è¯
        let quietMode = false;  // å®‰é™æ¨¡å¼ï¼ˆä¸ä¸»åŠ¨å¼•å¯¼ï¼‰

        // åˆ‡æ¢çµæ„Ÿæ‹æ‘„æ¨¡å¼ï¼ˆä¸æ»‘å¯åŠ¨ï¼‰
        function toggleInspirationMode() {
            inspirationMode = !inspirationMode;

            const aiCapsule = document.getElementById('aiCapsule');
            const aiStatusText = document.getElementById('aiStatusText');
            const aiControls = document.getElementById('aiControls'); // Float controls
            const feedback = document.getElementById('feedback');
            const vadIndicator = document.getElementById('vadIndicator');

            if (inspirationMode) {
                // å¯ç”¨çµæ„Ÿæ¨¡å¼
                unlockAudio(); // ç”¨æˆ·ç‚¹å‡»æŒ‰é’®æ—¶è§£é”éŸ³é¢‘ä¸Šä¸‹æ–‡
                aiCapsule.classList.add('active');
                aiStatusText.textContent = 'æ™ºèƒ½æ‹ç…§æ¨¡å¼';
                aiControls.style.display = 'flex';

                feedback.style.display = 'block';
                feedback.textContent = 'ğŸ¤ è¯·ç›´æ¥è¯´è¯ï¼Œæ¯”å¦‚"å¸®æˆ‘æ‹ç…§"';

                // æ˜¾ç¤º VAD æŒ‡ç¤ºå™¨
                vadIndicator.style.opacity = '1';

                // å¯ç”¨æŒç»­ç›‘å¬æ¨¡å¼
                conversationMode = true;

                // å¯åŠ¨æ™ºèƒ½è¯­éŸ³è¯†åˆ«
                const smartRec = initSmartRecognition();
                if (smartRec) {
                    try {
                        smartRec.start();
                    } catch (e) {
                        console.error('å¯åŠ¨è¯­éŸ³è¯†åˆ«å¤±è´¥:', e);
                    }
                }

                // å¯ç”¨ VAD ç›‘å¬
                enableInterruptMode();

                speak('æ™ºèƒ½æ¨¡å¼å·²å¯åŠ¨');
                console.log('âœ¨ æ™ºèƒ½æ‹ç…§æ¨¡å¼å·²å¯åŠ¨');
            } else {
                // å…³é—­çµæ„Ÿæ¨¡å¼
                aiCapsule.classList.remove('active');
                aiStatusText.textContent = 'AI åŠ©æ‰‹';
                aiControls.style.display = 'none';

                feedback.style.display = 'none';
                vadIndicator.style.opacity = '0';

                // å…³é—­æŒç»­ç›‘å¬
                conversationMode = false;

                // åœæ­¢è¯­éŸ³è¯†åˆ«
                if (recognition) {
                    try {
                        recognition.stop();
                    } catch (e) { }
                }

                // ç¦ç”¨ VAD
                disableVAD();

                console.log('ğŸ“· åˆ‡æ¢åˆ°æ™®é€šæ‹æ‘„æ¨¡å¼');
            }
        }

        // Settings Toggle
        function toggleSettings() {
            const overlay = document.getElementById('settingsOverlay');
            if (overlay.classList.contains('show')) {
                overlay.classList.remove('show');
            } else {
                overlay.classList.add('show');
            }
        }

        // æ›´æ–°åç«¯åœ°å€
        function updateApiUrl() {
            const input = document.getElementById('apiUrlInput');
            const status = document.getElementById('apiStatus');
            let url = input.value.trim();
            
            if (!url) {
                // å¦‚æœæ²¡æœ‰è¾“å…¥ï¼Œä½¿ç”¨è‡ªåŠ¨æ£€æµ‹çš„åœ°å€
                url = getBackendUrl();
                input.value = url;
            }
            
            // ç¡®ä¿ URL æ ¼å¼æ­£ç¡®
            if (!url.startsWith('http')) {
                url = 'http://' + url;
                input.value = url;
            }
            
            status.textContent = 'ğŸ”„ æµ‹è¯•è¿æ¥ä¸­...';
            status.style.color = 'rgba(255,255,255,0.6)';
            
            // æµ‹è¯•è¿æ¥
            fetch(`${url}/health`, { method: 'GET', timeout: 5000 })
                .then(res => {
                    if (res.ok) {
                        status.textContent = 'âœ… è¿æ¥æˆåŠŸï¼';
                        status.style.color = '#34c759';
                        // æ›´æ–° API_URL
                        API_URL = url;
                        console.log('ğŸ”— åç«¯åœ°å€å·²æ›´æ–°:', API_URL);
                    } else {
                        status.textContent = 'âŒ è¿æ¥å¤±è´¥';
                        status.style.color = '#ff3b30';
                    }
                })
                .catch(e => {
                    status.textContent = 'âŒ è¿æ¥å¤±è´¥: ' + e.message;
                    status.style.color = '#ff3b30';
                });
        }

        // æ˜¾ç¤ºçµæ„Ÿåº“
        function showInspirationGallery() {
            document.getElementById('feedback').textContent = 'ğŸ’¡ å¯ä»¥ç›´æ¥è¯´"æˆ‘æƒ³æ‹æˆ·å¤–"ã€"å¸®æˆ‘æ¢ä¸ªå§¿åŠ¿"';
        }

        // ===== æ™ºèƒ½è¯­éŸ³è¯†åˆ« =====
        // æœ¬åœ°æ„å›¾è¯†åˆ«ï¼ˆå¿«é€Ÿå“åº”ï¼‰
        function recognizeIntent(text) {
            const t = text.toLowerCase().trim();

            // æ‹ç…§æŒ‡ä»¤
            if (t.includes('æ‹') && (t.includes('å§') || t.includes('ç…§') || t === 'æ‹' || t.includes('å¥½äº†') || t.includes('å°±è¿™ä¸ª'))) {
                return { action: 'capture', confidence: 0.9 };
            }

            // æ¢å§¿åŠ¿æŒ‡ä»¤
            if ((t.includes('æ¢') || t.includes('ä¸') || t.includes('ä¸å¥½')) && (t.includes('å§¿åŠ¿') || t.includes('æ¢ä¸ª') || t.includes('æ¢ä¸€'))) {
                return { action: 'change_pose', confidence: 0.8 };
            }

            // è°ƒæ•´æŒ‡ä»¤
            if ((t.includes('çŸ®') || t.includes('ä½') || t.includes('è¹²') || t.includes('é«˜') || t.includes('æŠ¬')) && (t.includes('ç‚¹') || t.includes('ä¸€ç‚¹'))) {
                return { action: 'adjust', text: t, confidence: 0.7 };
            }

            // è¯¢é—®æŒ‡ä»¤
            if (t.includes('æ€ä¹ˆæ ·') || t.includes('å¥½çœ‹') || t.includes('è¡Œå—')) {
                return { action: 'ask', confidence: 0.6 };
            }

            // å…¶ä»–å¯¹è¯
            return { action: 'ai', text: text, confidence: 0.5 };
        }

        function initSmartRecognition() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) {
                console.warn('âš ï¸ æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ«');
                return null;
            }

            recognition = new SpeechRecognition();
            recognition.lang = 'zh-CN';
            recognition.continuous = true;
            recognition.interimResults = true;
            recognition.maxAlternatives = 1;

            recognition.onstart = () => {
                isRecording = true;
                console.log('ğŸ¤ æ™ºèƒ½ç›‘å¬å·²å¯åŠ¨');
            };

            recognition.onresult = (event) => {
                let finalTranscript = '';
                let interimTranscript = '';

                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript;
                    } else {
                        interimTranscript += transcript;
                    }
                }

                if (interimTranscript) {
                    document.getElementById('feedback').textContent = `ğŸ¤ "${interimTranscript}"`;
                }

                if (finalTranscript) {
                    handleUserVoice(finalTranscript);
                }
            };

            recognition.onerror = (event) => {
                if (event.error !== 'no-speech') {
                    console.log('ğŸ¤ è¯­éŸ³è¯†åˆ«: %s', event.error);
                }
            };

            recognition.onend = () => {
                isRecording = false;
                if (inspirationMode && recognition) {
                    try {
                        recognition.start();
                    } catch (e) { }
                }
            };

            return recognition;
        }

        // å¿«é€Ÿå“åº”ç”¨æˆ·è¯­éŸ³
        function handleUserVoice(voiceText) {
            const cleanText = voiceText.trim();
            if (!cleanText || cleanText === lastUserQuery) return;

            lastUserQuery = cleanText;
            console.log('ğŸ—£ï¸ ç”¨æˆ·è¯´:', cleanText);

            document.getElementById('feedback').textContent = `ğŸ’­ "${cleanText}"`;

            // æœ¬åœ°å¿«é€Ÿè¯†åˆ«æ„å›¾
            const intent = recognizeIntent(cleanText);
            console.log('ğŸ¯ æ„å›¾:', intent.action);

            switch (intent.action) {
                case 'capture':
                    // ç«‹å³æ‹ç…§
                    document.getElementById('feedback').textContent = 'ğŸ“¸ å¥½çš„ï¼Œæ‹ç…§ï¼';
                    speak('çœ‹é•œå¤´ï¼');
                    setTimeout(() => capture(), 500);
                    break;

                case 'change_pose':
                    changeToRandomPose();
                    break;

                case 'adjust':
                    document.getElementById('feedback').textContent = getAdjustmentTip(cleanText);
                    speak(getAdjustmentTip(cleanText));
                    break;

                case 'ask':
                    const answer = getQuickAnswer(cleanText);
                    document.getElementById('feedback').textContent = answer;
                    speak(answer);
                    break;

                case 'ai':
                    processUserRequest(cleanText);
                    break;
            }
        }

        function getAdjustmentTip(text) {
            const t = text.toLowerCase();
            if (t.includes('çŸ®') || t.includes('ä½') || t.includes('è¹²')) return 'å¥½çš„ï¼Œè¹²ä¸€ç‚¹';
            if (t.includes('é«˜') || t.includes('æŠ¬')) return 'å¥½çš„ï¼ŒæŠ¬é«˜ä¸€ç‚¹';
            return 'å¥½çš„ï¼Œè°ƒæ•´ä¸€ä¸‹';
        }

        function getQuickAnswer(text) {
            const t = text.toLowerCase();
            if (t.includes('æ€ä¹ˆæ ·')) return 'æŒºå¥½çš„ï¼Œä¿æŒè¿™ä¸ªå§¿åŠ¿ï¼';
            if (t.includes('å¥½çœ‹')) return 'ä¸é”™ä¸é”™ï¼';
            return 'æˆ‘è§‰å¾—æŒºå¥½çœ‹çš„ï¼';
        }

        function changeToRandomPose() {
            const poseKeys = Object.keys(poses);
            const currentIndex = poseKeys.indexOf(currentPose);
            let newIndex;
            do {
                newIndex = Math.floor(Math.random() * poseKeys.length);
            } while (newIndex === currentIndex && poseKeys.length > 1);

            currentPose = poseKeys[newIndex];
            document.getElementById('poseDropdown').value = currentPose;

            const tips = ['æ¢ä¸ªå§¿åŠ¿è¯•è¯•', 'æ¥ï¼Œæ¢è¿™ä¸ª', 'è¿™ä¸ªå§¿åŠ¿ä¸é”™'];
            document.getElementById('feedback').textContent = tips[Math.floor(Math.random() * tips.length)];
            speak(tips[Math.floor(Math.random() * tips.length)]);
        }

        // å¤„ç†ç”¨æˆ·è¯·æ±‚
        async function processUserRequest(userText) {
            if (isAnalyzing) return;

            isAnalyzing = true;
            const startTime = Date.now();

            // æ˜¾ç¤º AI åˆ†æä¸­çŠ¶æ€
            const aiAnalyzing = document.getElementById('aiAnalyzing');
            if (aiAnalyzing) {
                aiAnalyzing.classList.add('active');
            }

            try {
                const video = document.getElementById('video');
                if (!video || video.videoWidth === 0) return;

                // æ•è·å½“å‰ç”»é¢
                const canvas = document.createElement('canvas');
                canvas.width = 480;
                canvas.height = 360;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, 0, 0, 480, 360);
                const imageBase64 = canvas.toDataURL('image/jpeg', 0.5).split(',')[1];

                // ä½¿ç”¨ MiniMax è¿›è¡Œåˆ†æ
                const response = await fetch(`${API_URL}/analyze_image`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        image_base64: imageBase64,
                        image_format: 'jpeg',
                        user_message: userText
                    })
                });

                const elapsed = Date.now() - startTime;
                console.log(`â±ï¸ MiniMax å“åº”æ—¶é—´: ${elapsed}ms`);

                if (response.ok) {
                    const result = await response.json();
                    if (result.success && result.data) {
                        handleAIConversation(result.data, userText);
                    }
                } else {
                    console.error('AI åˆ†æå¤±è´¥:', response.status);
                    document.getElementById('feedback').textContent = 'âš ï¸ AI åˆ†æå¤±è´¥';
                }
            } catch (e) {
                console.error('å¤„ç†è¯·æ±‚é”™è¯¯:', e);
                document.getElementById('feedback').textContent = 'âš ï¸ ç½‘ç»œé—®é¢˜ï¼Œè¯·é‡è¯•';
            } finally {
                isAnalyzing = false;
                // éšè— AI åˆ†æä¸­çŠ¶æ€
                if (aiAnalyzing) {
                    aiAnalyzing.classList.remove('active');
                }
            }
        }

        // å¤„ç† AI å¯¹è¯å“åº”
        function handleAIConversation(data, userText) {
            const feedback = document.getElementById('feedback');
            const action = data.action || 'continue';

            // ç»Ÿä¸€å¤„ç†
            if (data.recommended_pose_id && poses[data.recommended_pose_id]) {
                currentPose = data.recommended_pose_id;
                const dropdown = document.getElementById('poseDropdown');
                if (dropdown) dropdown.value = currentPose;
            }

            // æ ¹æ® action æ‰§è¡Œ
            switch (action) {
                case 'capture':
                    feedback.textContent = 'ğŸ“¸ å¥½çš„ï¼Œæ‹ç…§ï¼';
                    speak('çœ‹é•œå¤´ï¼ŒèŒ„å­ï¼');
                    setTimeout(() => capture(), 800);
                    break;

                case 'change_pose':
                    feedback.textContent = data.voice_feedback || 'ğŸ”„ æ¢ä¸ªå§¿åŠ¿';
                    speak(data.voice_feedback || 'æ¥ï¼Œæ¢ä¸ªå§¿åŠ¿');
                    break;

                case 'talk':
                    feedback.textContent = data.voice_feedback || 'ğŸ’¬';
                    speak(data.voice_feedback);
                    break;

                case 'continue':
                default:
                    if (data.voice_feedback) {
                        feedback.textContent = data.voice_feedback;
                        speak(data.voice_feedback);
                    }
            }
        }

        // ===== å›¾ç‰‡å‹ç¼©ä¼˜åŒ–é…ç½® =====
        const IMAGE_QUALITY_PRESETS = {
            fast: { width: 320, height: 240, quality: 0.35, format: 'webp' },     // å¿«é€Ÿæ¨¡å¼ï¼š~10-15KB
            normal: { width: 480, height: 360, quality: 0.45, format: 'webp' },   // æ™®é€šæ¨¡å¼ï¼š~20-30KB
            high: { width: 640, height: 480, quality: 0.55, format: 'webp' }      // é«˜è´¨é‡ï¼š~40-50KB
        };
        let currentQualityPreset = 'normal';
        let networkLatency = 0;

        // æ£€æµ‹æµè§ˆå™¨æ˜¯å¦æ”¯æŒ WebP
        const supportsWebP = (() => {
            const canvas = document.createElement('canvas');
            canvas.width = 1;
            canvas.height = 1;
            return canvas.toDataURL('image/webp').indexOf('data:image/webp') === 0;
        })();

        // ===== è¯­éŸ³è¯†åˆ«é…ç½® =====
        let userVoiceInput = null;  // å­˜å‚¨ç”¨æˆ·è¯­éŸ³è¾“å…¥

        // åˆå§‹åŒ–è¯­éŸ³è¯†åˆ«
        function initSpeechRecognition() {
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SpeechRecognition) {
                console.warn('âš ï¸ æµè§ˆå™¨ä¸æ”¯æŒè¯­éŸ³è¯†åˆ«');
                return null;
            }

            recognition = new SpeechRecognition();
            recognition.lang = 'zh-CN';
            recognition.continuous = false;
            recognition.interimResults = true;

            recognition.onstart = () => {
                isRecording = true;
                document.getElementById('micBtn').classList.add('recording');
                document.getElementById('micBtn').textContent = 'ğŸ”´';
                document.getElementById('feedback').textContent = 'ğŸ¤ æ­£åœ¨å¬æ‚¨è¯´è¯...';
                console.log('ğŸ¤ å¼€å§‹è¯­éŸ³è¯†åˆ«');
            };

            recognition.onresult = (event) => {
                let finalTranscript = '';
                let interimTranscript = '';

                for (let i = event.resultIndex; i < event.results.length; i++) {
                    const transcript = event.results[i][0].transcript;
                    if (event.results[i].isFinal) {
                        finalTranscript += transcript;
                    } else {
                        interimTranscript += transcript;
                    }
                }

                // æ˜¾ç¤ºä¸´æ—¶ç»“æœ
                if (interimTranscript) {
                    document.getElementById('feedback').textContent = `ğŸ¤ "${interimTranscript}"`;
                }

                // æœ€ç»ˆç»“æœ
                if (finalTranscript) {
                    userVoiceInput = finalTranscript;
                    console.log('ğŸ—£ï¸ è¯­éŸ³è¯†åˆ«ç»“æœ:', finalTranscript);
                    document.getElementById('feedback').textContent = `ğŸ—£ï¸ æ‚¨è¯´: "${finalTranscript}"`;

                    // ç›´æ¥å‘é€ç»™ AIï¼Œè®© AI ç†è§£ç”¨æˆ·æ„å›¾
                    setTimeout(() => {
                        analyzeWithVoice(finalTranscript);
                    }, 500);
                }
            };

            recognition.onerror = (event) => {
                console.error('âŒ è¯­éŸ³è¯†åˆ«é”™è¯¯:', event.error);
                document.getElementById('feedback').textContent = `âš ï¸ è¯­éŸ³è¯†åˆ«å¤±è´¥: ${event.error}`;
                stopRecording();
            };

            recognition.onend = () => {
                stopRecording();
            };

            return recognition;
        }

        // å®‰é™æ¨¡å¼åˆ‡æ¢ï¼ˆAI ä¸ä¸»åŠ¨å¼•å¯¼ï¼Œåªå›åº”ç”¨æˆ·ï¼‰
        function toggleMicrophone() {
            quietMode = !quietMode;
            const micIcon = document.getElementById('micIcon');
            const micText = document.getElementById('micText');

            if (quietMode) {
                if (micIcon) micIcon.textContent = 'ğŸ”‡';
                if (micText) micText.textContent = 'å®‰é™æ¨¡å¼';
                document.getElementById('feedback').textContent = 'ğŸ”‡ å®‰é™æ¨¡å¼ - æˆ‘ä¼šä¿æŒå®‰é™ï¼Œç­‰ä½ å«æˆ‘';
                console.log('ğŸ”‡ å®‰é™æ¨¡å¼å¼€å¯');
            } else {
                if (micIcon) micIcon.textContent = 'ğŸ¤';
                if (micText) micText.textContent = 'è¯­éŸ³æ¨¡å¼';
                document.getElementById('feedback').textContent = 'ğŸ¤ æ­£å¸¸æ¨¡å¼ - æˆ‘ä¼šé€‚æ—¶ç»™ä½ å»ºè®®';
                console.log('ğŸ¤ å®‰é™æ¨¡å¼å…³é—­');
            }
        }

        // ===== è¯­éŸ³è¯†åˆ«æ§åˆ¶ =====
        function startRecording() {
            if (recognition && !isRecording) {
                try {
                    recognition.start();
                } catch (e) { }
            }
        }

        function stopRecording() {
            if (recognition && isRecording) {
                try {
                    recognition.stop();
                } catch (e) { }
            }
        }

        // ===== VAD è¯­éŸ³æ´»åŠ¨æ£€æµ‹å˜é‡ =====
        let vadEnabled = false;
        let vadInterval = null;
        let isUserSpeaking = false;
        let audioContext = null;
        let analyser = null;
        let vadStream = null;
        let speechStartTime = 0;
        const VAD_SPEECH_THRESHOLD = 0.008;
        const VAD_CHECK_INTERVAL = 30;
        const SPEECH_DEBOUNCE_MS = 100;

        // ç»Ÿä¸€è§¦å‘æ‹ç…§
        function triggerCapture(mode = 'auto') {
            console.log(`ğŸ“¸ è§¦å‘æ‹ç…§ - æ¨¡å¼: ${mode}`);

            const feedback = document.getElementById('feedback');
            const originalText = feedback.textContent;
            feedback.textContent = 'ğŸ“¸ æ­£åœ¨æ‹æ‘„...';

            capture();

            setTimeout(() => {
                feedback.textContent = originalText;
            }, 2000);
        }

        // ===== è¯­éŸ³æ´»åŠ¨æ£€æµ‹ (VAD) - å®ç°æ‰“æ–­æœºåˆ¶ =====

        // åˆå§‹åŒ– VADï¼ˆè¯­éŸ³æ´»åŠ¨æ£€æµ‹ï¼‰
        async function initVAD() {
            if (vadEnabled) return true;

            // æ£€æŸ¥æµè§ˆå™¨æ˜¯å¦æ”¯æŒ AudioContext
            if (!window.AudioContext && !window.webkitAudioContext) {
                console.warn('âš ï¸ æµè§ˆå™¨ä¸æ”¯æŒ AudioContext');
                return false;
            }

            try {
                // è¯·æ±‚éº¦å…‹é£æƒé™ç”¨äº VAD
                vadStream = await navigator.mediaDevices.getUserMedia({ audio: true });

                // åˆ›å»ºéŸ³é¢‘ä¸Šä¸‹æ–‡
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaStreamSource(vadStream);

                // åˆ›å»ºåˆ†æå™¨
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
                analyser.smoothingTimeConstant = 0.8;
                source.connect(analyser);

                vadEnabled = true;
                console.log('âœ… VAD è¯­éŸ³æ´»åŠ¨æ£€æµ‹å·²å¯åŠ¨');

                // å¯åŠ¨ VAD æ£€æµ‹å¾ªç¯
                startVADLoop();

                return true;
            } catch (e) {
                console.warn('âš ï¸ VAD åˆå§‹åŒ–å¤±è´¥:', e);
                return false;
            }
        }

        // å¯åŠ¨ VAD æ£€æµ‹å¾ªç¯
        function startVADLoop() {
            if (vadInterval) clearInterval(vadInterval);

            const dataArray = new Uint8Array(analyser.frequencyBinCount);

            vadInterval = setInterval(() => {
                if (!vadEnabled) return;

                analyser.getByteFrequencyData(dataArray);

                // è®¡ç®—æœ€å¤§éŸ³é‡ï¼ˆæ¯”å¹³å‡å€¼æ›´æ•æ„Ÿï¼‰
                let maxVolume = 0;
                for (let i = 0; i < dataArray.length; i++) {
                    if (dataArray[i] > maxVolume) {
                        maxVolume = dataArray[i];
                    }
                }

                // å½’ä¸€åŒ– 0-1
                const normalizedVolume = maxVolume / 255;

                // ä½¿ç”¨æœ€å¤§éŸ³é‡æ£€æµ‹ï¼Œæ›´çµæ•
                const isSpeechDetected = normalizedVolume > VAD_SPEECH_THRESHOLD;

                // çŠ¶æ€å˜åŒ–å¤„ç†
                if (isSpeechDetected && !isUserSpeaking) {
                    // ç”¨æˆ·å¼€å§‹è¯´è¯
                    isUserSpeaking = true;
                    speechStartTime = Date.now();
                    onUserSpeechStart();
                } else if (!isSpeechDetected && isUserSpeaking) {
                    // ç”¨æˆ·åœæ­¢è¯´è¯ï¼ˆå»æŠ–åŠ¨ï¼‰
                    if (Date.now() - speechStartTime > SPEECH_DEBOUNCE_MS) {
                        isUserSpeaking = false;
                        onUserSpeechEnd();
                    }
                }
            }, VAD_CHECK_INTERVAL);
        }

        // ç”¨æˆ·å¼€å§‹è¯´è¯æ—¶çš„å¤„ç†
        function onUserSpeechStart() {
            console.log('ğŸ‘¤ ç”¨æˆ·å¼€å§‹è¯´è¯ - æ‰“æ–­ AI');

            // æ›´æ–° VAD æŒ‡ç¤ºå™¨
            updateVADIndicator(true);

            // 1. ç«‹å³åœæ­¢ TTS æ’­æ”¾
            stopTTS();
            ttsInterrupted = true;

            // 2. å¦‚æœæ­£åœ¨è¿›è¡Œè¯­éŸ³è¯†åˆ«ï¼Œé‡å¯å®ƒ
            if (isRecording && recognition) {
                try {
                    recognition.stop();
                } catch (e) { }
            }

            // 3. æ›´æ–° UI åé¦ˆ
            showInterruptFeedback();

            // 4. è‡ªåŠ¨å¼€å§‹è¯­éŸ³è¯†åˆ«
            setTimeout(() => {
                if (!isRecording) {
                    startRecording();
                }
            }, 300);
        }

        // ç”¨æˆ·åœæ­¢è¯´è¯æ—¶çš„å¤„ç†
        function onUserSpeechEnd() {
            console.log('ğŸ‘¤ ç”¨æˆ·åœæ­¢è¯´è¯');
            updateVADIndicator(false);
        }

        // æ˜¾ç¤ºæ‰“æ–­åé¦ˆ
        function showInterruptFeedback() {
            // æ˜¾ç¤ºæ‰“æ–­æç¤º toast
            const toast = document.getElementById('interruptToast');
            toast.classList.add('show');

            // 1.5ç§’åéšè—
            setTimeout(() => {
                toast.classList.remove('show');
            }, 1500);

            // æ›´æ–°åé¦ˆåŒºåŸŸ
            const feedback = document.getElementById('feedback');
            feedback.textContent = 'ğŸ‘¤ æ­£åœ¨å€¾å¬...';

            ttsInterrupted = false;
        }

        // æ›´æ–° VAD æŒ‡ç¤ºå™¨çŠ¶æ€
        function updateVADIndicator(isActive) {
            const indicator = document.getElementById('vadIndicator');
            if (isActive) {
                indicator.classList.add('active');
            } else {
                indicator.classList.remove('active');
            }
        }

        // å¯ç”¨æ‰“æ–­æ¨¡å¼
        async function enableInterruptMode() {
            const success = await initVAD();
            if (success) {
                console.log('ğŸ”Š æ‰“æ–­æ¨¡å¼å·²å¯ç”¨');
            }
            return success;
        }

        // ç¦ç”¨ VAD
        function disableVAD() {
            vadEnabled = false;

            if (vadInterval) {
                clearInterval(vadInterval);
                vadInterval = null;
            }

            if (vadStream) {
                vadStream.getTracks().forEach(track => track.stop());
                vadStream = null;
            }

            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }

            isUserSpeaking = false;
            console.log('ğŸ”‡ æ‰“æ–­æ¨¡å¼å·²ç¦ç”¨');
        }

        // å¸¦è¯­éŸ³è¾“å…¥çš„ AI åˆ†æ
        async function analyzeWithVoice(voiceText) {
            if (isAnalyzing) return;

            const video = document.getElementById('video');
            if (!video || video.videoWidth === 0) return;

            isAnalyzing = true;
            const startTime = Date.now();

            try {
                const imageResult = captureOptimizedFrame(video, currentQualityPreset);

                document.getElementById('feedback').textContent = `ğŸ¤– AI æ­£åœ¨å¤„ç†: "${voiceText}"...`;

                const response = await fetch(`${API_URL}/analyze_image`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        image_base64: imageResult.base64,
                        image_format: imageResult.format,
                        user_message: voiceText  // ä¼ é€’è¯­éŸ³è¾“å…¥
                    })
                });

                const responseTime = Date.now() - startTime;

                if (response.ok) {
                    const result = await response.json();
                    console.log(`âœ… AI è¯­éŸ³å“åº” (${responseTime}ms):`, result);

                    if (result.success && result.data) {
                        handleAIConversation(result.data, voiceText);
                    } else if (result.error) {
                        document.getElementById('feedback').textContent = `âš ï¸ ${result.error}`;
                    }
                } else {
                    document.getElementById('feedback').textContent = `âš ï¸ API é”™è¯¯`;
                }
            } catch (e) {
                console.error('AI è¯­éŸ³åˆ†æé”™è¯¯:', e);
                document.getElementById('feedback').textContent = 'âš ï¸ æ— æ³•è¿æ¥åç«¯';
            } finally {
                isAnalyzing = false;
                userVoiceInput = null;
            }
        }

        // åˆå§‹åŒ–
        async function init() {
            // åŠ è½½å§¿åŠ¿æ•°æ®ï¼ˆéé˜»å¡ï¼‰
            fetch('../poses.json')
                .then(res => res.json())
                .then(data => {
                    poses = data.poses && typeof data.poses === 'object' ? data.poses : data;
                    console.log('å·²åŠ è½½å§¿åŠ¿æ•°æ®:', Object.keys(poses));
                })
                .catch(e => console.warn('æ— æ³•åŠ è½½å§¿åŠ¿æ•°æ®:', e));

            // å¯åŠ¨æ‘„åƒå¤´ï¼ˆéé˜»å¡ï¼‰
            const video = document.getElementById('video');
            navigator.mediaDevices.getUserMedia({ video: { facingMode: 'user', width: 640, height: 480 } })
                .then(stream => {
                    video.srcObject = stream;
                    video.play();
                })
                .catch(e => {
                    console.error('æ‘„åƒå¤´å¯åŠ¨å¤±è´¥:', e);
                    document.getElementById('feedback').textContent = 'âš ï¸ è¯·å…è®¸æ‘„åƒå¤´æƒé™';
                });

            // ç«‹å³éšè—åŠ è½½ç•Œé¢
            document.getElementById('loading').classList.add('hidden');
            document.getElementById('feedback').textContent = 'ç‚¹å‡» âœ¨ å¼€å¯æ™ºèƒ½æ‹ç…§';

            // åå°åˆå§‹åŒ–
            initSmartRecognition();
            checkAIStatus();
            measureNetworkLatency();
            console.log('ğŸ“· å‡†å¤‡å°±ç»ª');
        }

        // æµ‹é‡ç½‘ç»œå»¶è¿Ÿï¼Œè‡ªåŠ¨é€‰æ‹©æœ€ä½³å›¾ç‰‡è´¨é‡ï¼ˆå¸¦è¶…æ—¶ï¼‰
        async function measureNetworkLatency() {
            const start = Date.now();
            try {
                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), 3000);

                await fetch(`${API_URL}/health`, {
                    method: 'GET',
                    signal: controller.signal
                });
                clearTimeout(timeout);

                networkLatency = Date.now() - start;
                if (networkLatency > 500) {
                    currentQualityPreset = 'fast';
                } else if (networkLatency > 200) {
                    currentQualityPreset = 'normal';
                } else {
                    currentQualityPreset = 'high';
                }
                console.log(`ğŸŒ ç½‘ç»œå»¶è¿Ÿ: ${networkLatency}ms, ä½¿ç”¨è´¨é‡: ${currentQualityPreset}`);
            } catch (e) {
                networkLatency = 1000;
                currentQualityPreset = 'fast';
                console.warn('âš ï¸ åç«¯è¿æ¥å¤±è´¥ï¼Œä½¿ç”¨å¿«é€Ÿæ¨¡å¼');
            }
        }

        // æ£€æŸ¥ AI æœåŠ¡çŠ¶æ€ï¼ˆå¸¦è¶…æ—¶ï¼‰
        async function checkAIStatus() {
            try {
                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), 3000);

                const mcpResponse = await fetch(`${API_URL}/mcp/info`, { signal: controller.signal });
                clearTimeout(timeout);

                if (mcpResponse.ok) {
                    const mcpData = await mcpResponse.json();
                    const mcpIndicator = document.getElementById('mcpIndicator');
                    if (mcpData.enabled) {
                        mcpIndicator.classList.add('active');
                    }
                }
            } catch (e) {
                console.log('â„¹ï¸ AI çŠ¶æ€æ£€æŸ¥å®Œæˆ');
            }
        }

        // æ£€æŸ¥ç¯å¢ƒå˜é‡
        async function checkEnvKey(envKey) {
            try {
                const response = await fetch(`${API_URL}/health`);
                if (response.ok) {
                    const data = await response.json();
                    return data.providers?.[envKey.replace('_API_KEY', '')]?.configured;
                }
            } catch (e) { }
            return false;
        }

        // æ™ºèƒ½å›¾ç‰‡å‹ç¼© - ä½¿ç”¨ WebP æ ¼å¼
        function captureOptimizedFrame(video, presetName = 'normal') {
            const preset = IMAGE_QUALITY_PRESETS[presetName] || IMAGE_QUALITY_PRESETS.normal;
            const canvas = document.createElement('canvas');
            canvas.width = preset.width;
            canvas.height = preset.height;

            const ctx = canvas.getContext('2d');
            ctx.drawImage(video, 0, 0, preset.width, preset.height);

            // ä¼˜å…ˆä½¿ç”¨ WebPï¼ˆæ›´å°ï¼‰ï¼Œé™çº§åˆ° JPEG
            const format = supportsWebP ? 'image/webp' : 'image/jpeg';
            const imageData = canvas.toDataURL(format, preset.quality);

            // è®°å½•å‹ç¼©ä¿¡æ¯
            const base64Data = imageData.split(',')[1];
            const sizeKB = (base64Data.length * 0.75 / 1024).toFixed(1);
            console.log(`ğŸ“¸ å›¾ç‰‡å‹ç¼©: ${preset.width}x${preset.height}, è´¨é‡${preset.quality}, æ ¼å¼${format.split('/')[1]}, å¤§å°~${sizeKB}KB`);

            return {
                base64: base64Data,
                format: supportsWebP ? 'webp' : 'jpeg',
                size: parseFloat(sizeKB)
            };
        }

        // æ¸²æŸ“å¾ªç¯
        function renderLoop() {
            const canvas = document.getElementById('canvas');
            const video = document.getElementById('video');
            const ctx = canvas.getContext('2d');

            if (video.readyState >= 2) {
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;

                // é•œåƒæ˜¾ç¤º
                ctx.save();
                ctx.scale(-1, 1);
                ctx.translate(-canvas.width, 0);

                // 1. ç»˜åˆ¶è§†é¢‘èƒŒæ™¯
                ctx.drawImage(video, 0, 0);

                ctx.restore();
            }

            // æ™ºèƒ½æ‹ç…§æ¨¡å¼ä¸‹æŒç»­åˆ†æ
            if (inspirationMode && !isAnalyzing) {
                const now = Date.now();

                // ç”¨æˆ·è¯´è¯åç«‹å³åˆ†æå½“å‰ç”»é¢
                if (lastUserQuery) {
                    realtimeAnalysis(lastUserQuery);
                    lastUserQuery = '';
                } else if (now - lastAnalysisTime > ANALYSIS_INTERVAL) {
                    // å®šæ—¶åˆ†æå½“å‰ç”»é¢ï¼ˆä¸å‘é€ç”¨æˆ·æ¶ˆæ¯ï¼‰
                    analyzeCurrentFrame();
                }
            }

            requestAnimationFrame(renderLoop);
        }

        // ç”¨æˆ·è¯´è¯æ—¶è§¦å‘å®æ—¶åˆ†æ
        async function realtimeAnalysis(userText) {
            if (isAnalyzing) return;

            isAnalyzing = true;
            lastAnalysisTime = Date.now();

            try {
                const video = document.getElementById('video');
                if (!video || video.videoWidth === 0) return;

                // æ•è·å½“å‰ç”»é¢
                const imageResult = captureOptimizedFrame(video, 'fast');
                document.getElementById('feedback').textContent = `ğŸ’­ "${userText}"`;

                const response = await fetch(`${API_URL}/analyze_image`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        image_base64: imageResult.base64,
                        image_format: imageResult.format,
                        user_message: userText
                    })
                });

                if (response.ok) {
                    const result = await response.json();
                    if (result.success && result.data) {
                        handleAIConversation(result.data, userText);
                    }
                }
            } catch (e) {
                console.error('å®æ—¶åˆ†æé”™è¯¯:', e);
            } finally {
                isAnalyzing = false;
            }
        }

        // å®šæ—¶åˆ†æå½“å‰ç”»é¢ï¼ˆæ— ç”¨æˆ·è¾“å…¥ï¼‰
        async function analyzeCurrentFrame() {
            if (isAnalyzing) return;

            isAnalyzing = true;
            lastAnalysisTime = Date.now();

            try {
                const video = document.getElementById('video');
                if (!video || video.videoWidth === 0) return;

                const imageResult = captureOptimizedFrame(video, 'fast');

                const response = await fetch(`${API_URL}/analyze_image`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        image_base64: imageResult.base64,
                        image_format: imageResult.format
                    })
                });

                if (response.ok) {
                    const result = await response.json();
                    if (result.success && result.data) {
                        // å®šæ—¶åˆ†æåªæ›´æ–°å§¿åŠ¿ï¼Œä¸æ’­æŠ¥è¯­éŸ³
                        if (result.data.recommended_pose_id &&
                            poses[result.data.recommended_pose_id] &&
                            currentPose !== result.data.recommended_pose_id) {
                            currentPose = result.data.recommended_pose_id;
                            const dropdown = document.getElementById('poseDropdown');
                            if (dropdown) dropdown.value = currentPose;
                        }
                    }
                }
            } catch (e) {
                // é™é»˜å¤±è´¥
            } finally {
                isAnalyzing = false;
            }
        }

        requestAnimationFrame(renderLoop);

        // ç»˜åˆ¶ AI çŠ¶æ€
        function drawAIStatus(ctx) {
            // Polyfill for roundRect if not natively supported
            if (!CanvasRenderingContext2D.prototype.roundRect) {
                CanvasRenderingContext2D.prototype.roundRect = function (x, y, width, height, radius) {
                    if (typeof radius === 'number') {
                        radius = { tl: radius, tr: radius, br: radius, bl: radius };
                    } else if (typeof radius === 'object') {
                        radius = {
                            tl: radius.tl || 0,
                            tr: radius.tr || 0,
                            br: radius.br || 0,
                            bl: radius.bl || 0
                        };
                    } else {
                        radius = { tl: 0, tr: 0, br: 0, bl: 0 };
                    }
                    this.beginPath();
                    this.moveTo(x + radius.tl, y);
                    this.lineTo(x + width - radius.tr, y);
                    this.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
                    this.lineTo(x + width, y + height - radius.br);
                    this.quadraticCurveTo(x + width, y + height, x + width - radius.br, y + height);
                    this.lineTo(x + radius.bl, y + height);
                    this.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
                    this.lineTo(x, y + radius.tl);
                    this.quadraticCurveTo(x, y, x + radius.tl, y);
                    this.closePath();
                    return this;
                };
            }

            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.roundRect(5, 5, 200, 60, 10);
            ctx.fill();

            ctx.fillStyle = '#00ff78';
            ctx.font = 'bold 16px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`ğŸ“· åœºæ™¯: ${currentPose.split('_')[0]}`, 15, 30);

            if (isAnalyzing) {
                ctx.fillStyle = '#667eea';
                ctx.fillText('ğŸ¤– AI æ€è€ƒä¸­...', 15, 55);
            } else {
                ctx.fillStyle = '#fff';
                ctx.fillText('âœ… å®æ—¶ç›‘æ§ä¸­', 15, 55);
            }
        }

        // å¤„ç†æ£€æµ‹ç»“æœ
        function onResults(results) {
            const canvas = document.getElementById('canvas');
            const video = document.getElementById('video');
            const ctx = canvas.getContext('2d');

            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.scale(-1, 1);
            ctx.translate(-canvas.width, 0);

            // è·å–å½“å‰åœºæ™¯ç±»å‹
            const currentSceneType = getSceneType(currentPose);

            // ç»˜åˆ¶å¼•å¯¼æ¡†ï¼ˆæ‰€æœ‰åœºæ™¯éƒ½æ˜¾ç¤ºï¼‰
            if (isGuiding && document.getElementById('showGuide').checked) {
                drawGuide(ctx, canvas.width, canvas.height);
            }

            // æ™ºèƒ½åˆ¤æ–­æ˜¯å¦æ˜¾ç¤ºéª¨éª¼
            // è‡ªæ‹ã€æƒ…ä¾£ã€ç¾é£Ÿåœºæ™¯ä¸æ˜¾ç¤ºå®Œæ•´éª¨éª¼ï¼Œé¿å…é®æŒ¡è„¸éƒ¨
            const showFullSkeleton = !['selfie', 'couple', 'food'].includes(currentSceneType);

            if (results.poseLandmarks && document.getElementById('showSkeleton').checked) {
                if (showFullSkeleton) {
                    // å…¨èº«éª¨éª¼ï¼ˆä»–æ‹ã€åˆå½±ã€æˆ·å¤–ç­‰ï¼‰
                    drawConnectors(ctx, results.poseLandmarks, POSE_CONNECTIONS,
                        { color: 'rgba(255,255,255,0.6)', lineWidth: 2 });
                    drawLandmarks(ctx, results.poseLandmarks,
                        { color: 'rgba(255,255,255,0.8)', lineWidth: 1, radius: 4 });
                } else {
                    // ç®€åŒ–éª¨éª¼ï¼šåªæ˜¾ç¤ºè‚©è†€å’Œæ‰‹è‡‚è½®å»“ï¼ˆè‡ªæ‹æ¨¡å¼ï¼‰
                    const simplifiedConnections = [
                        [11, 12], [11, 13], [13, 15], [12, 14], [14, 16]
                    ];
                    simplifiedConnections.forEach(([i, j]) => {
                        if (results.poseLandmarks[i] && results.poseLandmarks[j]) {
                            ctx.strokeStyle = 'rgba(255,255,255,0.4)';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(results.poseLandmarks[i].x * canvas.width,
                                results.poseLandmarks[i].y * canvas.height);
                            ctx.lineTo(results.poseLandmarks[j].x * canvas.width,
                                results.poseLandmarks[j].y * canvas.height);
                            ctx.stroke();
                        }
                    });
                }
            }

            ctx.restore();

            // è®¡ç®—åŒ¹é…åº¦
            if (isGuiding && results.poseLandmarks) {
                calcScore(results.poseLandmarks);
            }
        }

        // æ ¹æ®å§¿åŠ¿IDåˆ¤æ–­åœºæ™¯ç±»å‹
        function getSceneType(poseId) {
            const p = poses[poseId];
            if (p && p.scene) return p.scene;

            // æ ¹æ®å§¿åŠ¿åç§°æ¨æ–­åœºæ™¯
            if (poseId.startsWith('selfie')) return 'selfie';
            if (poseId.startsWith('couple')) return 'couple';
            if (poseId.startsWith('group')) return 'group_small';
            if (poseId.includes('food') || poseId.includes('coffee') || poseId.includes('chin')) return 'food';
            if (poseId.includes('walking') || poseId.includes('looking') || poseId.includes('spread')) return 'outdoor';

            return 'portrait'; // é»˜è®¤ä»–æ‹æ¨¡å¼
        }

        // ç»˜åˆ¶å¼•å¯¼æ¡†
        function drawGuide(ctx, w, h) {
            const p = poses[currentPose];

            // è°ƒè¯•ä¿¡æ¯ï¼šå§‹ç»ˆæ˜¾ç¤ºå½“å‰çŠ¶æ€
            ctx.fillStyle = 'rgba(0, 255, 120, 0.9)';
            ctx.font = 'bold 18px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`å½“å‰å§¿åŠ¿: ${currentPose}`, 10, 30);
            ctx.fillText(`å§¿åŠ¿å­˜åœ¨: ${p ? 'âœ“' : 'âœ—'}`, 10, 55);
            ctx.fillText(`æœ‰landmarks: ${(p && p.landmarks) ? 'âœ“ (' + p.landmarks.length + 'ç‚¹)' : 'âœ—'}`, 10, 80);

            if (!p || !p.landmarks) {
                ctx.fillStyle = 'rgba(255, 100, 100, 0.9)';
                ctx.fillText('âš ï¸ æ— æ³•ç»˜åˆ¶å¼•å¯¼çº¿', 10, 105);
                console.warn('drawGuide: å§¿åŠ¿æœªæ‰¾åˆ°', currentPose, 'poses keys:', Object.keys(poses).slice(0, 5));
                return;
            }

            const lm = p.landmarks;
            const time = Date.now() / 1000;
            const pulse = 0.5 + 0.5 * Math.sin(time * 3);

            // æ˜¾ç¤ºå§¿åŠ¿åç§°
            if (p.name) {
                ctx.fillStyle = 'rgba(0, 255, 120, 0.9)';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`ğŸ“· ${p.name}`, w / 2, h - 30);
            }

            // å¤–å‘å…‰æ•ˆæœ
            ctx.shadowColor = 'rgba(0, 255, 120, 0.8)';
            ctx.shadowBlur = 15 + pulse * 10;

            // ç»˜åˆ¶è¿æ¥çº¿
            ctx.strokeStyle = `rgba(0, 255, 120, ${0.7 + pulse * 0.3})`;
            ctx.lineWidth = 8;
            ctx.setLineDash([25, 15]);
            ctx.lineCap = 'round';

            const connections = [
                [11, 12], [11, 13], [13, 15], [12, 14], [14, 16],
                [11, 23], [12, 24], [23, 24], [23, 25], [24, 26], [25, 27], [26, 28]
            ];

            connections.forEach(([i, j]) => {
                if (lm[i] && lm[j]) {
                    ctx.beginPath();
                    ctx.moveTo(lm[i][0] * w, lm[i][1] * h);
                    ctx.lineTo(lm[j][0] * w, lm[j][1] * h);
                    ctx.stroke();
                }
            });

            ctx.setLineDash([]);
            ctx.shadowBlur = 0;

            // ç»˜åˆ¶å…³é”®ç‚¹
            const keyPoints = [11, 12, 13, 14, 15, 16, 23, 24, 25, 26, 27, 28];
            keyPoints.forEach(i => {
                if (lm[i]) {
                    const x = lm[i][0] * w;
                    const y = lm[i][1] * h;

                    // è„‰å†²å¤–ç¯
                    ctx.strokeStyle = `rgba(0, 255, 120, ${0.4 + pulse * 0.3})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(x, y, 20 + pulse * 10, 0, Math.PI * 2);
                    ctx.stroke();

                    // å®å¿ƒåœ†
                    ctx.fillStyle = 'rgba(0, 255, 120, 0.9)';
                    ctx.beginPath();
                    ctx.arc(x, y, 12, 0, Math.PI * 2);
                    ctx.fill();

                    // æ˜¾ç¤ºç‚¹ç¼–å·ï¼ˆè°ƒè¯•ç”¨ï¼‰
                    ctx.fillStyle = '#000';
                    ctx.font = 'bold 10px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText(i, x, y + 4);
                }
            });
        }

        // è®¡ç®—åŒ¹é…åº¦
        function calcScore(userLm) {
            const p = poses[currentPose];
            if (!p || !p.landmarks) {
                console.warn('å§¿åŠ¿æ•°æ®æœªæ‰¾åˆ°:', currentPose, 'å¯ç”¨å§¿åŠ¿:', Object.keys(poses));
                score = 0;
                updateUI();
                return;
            }

            const tLm = p.landmarks;
            let sum = 0, cnt = 0;

            // è®¡ç®—æ‰‹è‡‚å‘é‡çš„ä½™å¼¦ç›¸ä¼¼åº¦
            [[11, 13], [13, 15], [12, 14], [14, 16]].forEach(([s, e]) => {
                if (!userLm[s] || !userLm[e] || !tLm[s] || !tLm[e]) return;

                const uv = { x: userLm[e].x - userLm[s].x, y: userLm[e].y - userLm[s].y };
                const tv = { x: tLm[e][0] - tLm[s][0], y: tLm[e][1] - tLm[s][1] };
                const dot = uv.x * tv.x + uv.y * tv.y;
                const m1 = Math.sqrt(uv.x * uv.x + uv.y * uv.y);
                const m2 = Math.sqrt(tv.x * tv.x + tv.y * tv.y);
                if (m1 > 0.001 && m2 > 0.001) {
                    sum += dot / (m1 * m2);
                    cnt++;
                }
            });

            if (cnt > 0) {
                score = Math.max(0, Math.min(100, ((sum / cnt + 1) / 2) * 100));
            } else {
                score = 50; // é»˜è®¤ä¸­é—´å€¼
            }

            updateUI();
            checkAuto();
        }

        // æ›´æ–°ç•Œé¢
        function updateUI() {
            const card = document.getElementById('scoreCard');
            const val = document.getElementById('scoreValue');
            const fb = document.getElementById('feedback');

            val.textContent = Math.round(score) + '%';
            card.className = 'score-card ' + (score >= 70 ? 'high' : score >= 50 ? 'medium' : 'low');

            if (score >= 85) fb.textContent = 'å®Œç¾ï¼ä¿æŒä½ï¼';
            else if (score >= 70) fb.textContent = 'å¾ˆå¥½ï¼å†è°ƒæ•´ä¸€ç‚¹';
            else if (score >= 50) fb.textContent = 'ç»§ç»­è°ƒæ•´...';
            else fb.textContent = 'ç§»åŠ¨åˆ°ç»¿è‰²å¼•å¯¼æ¡†';
        }

        // è‡ªåŠ¨æ‹ç…§æ£€æµ‹
        function checkAuto() {
            const threshold = parseInt(document.getElementById('threshold').value);
            if (score >= threshold) {
                if (!highScoreTime) highScoreTime = Date.now();
                else if (Date.now() - highScoreTime >= 2000) countdown();
            } else {
                highScoreTime = null;
            }
        }

        // å€’è®¡æ—¶
        async function countdown() {
            highScoreTime = null;
            const el = document.getElementById('countdown');

            for (let i = 3; i >= 1; i--) {
                el.textContent = i;
                el.style.display = 'block';
                el.style.animation = 'none';
                el.offsetHeight;
                el.style.animation = 'pop 0.4s ease-out';
                if (voiceOn) speak(String(i));
                await new Promise(r => setTimeout(r, 1000));
            }

            el.style.display = 'none';
            capture();
        }

        // æ‹ç…§
        function capture() {
            const video = document.getElementById('video');
            const c = document.createElement('canvas');
            c.width = video.videoWidth;
            c.height = video.videoHeight;
            const ctx = c.getContext('2d');
            ctx.scale(-1, 1);
            ctx.translate(-c.width, 0);
            ctx.drawImage(video, 0, 0);

            const url = c.toDataURL('image/jpeg', 0.9);

            const previewImg = document.getElementById('previewImg');
            if (previewImg) {
                previewImg.src = url;
                previewImg.style.display = 'block';
            }

            const perfect = document.getElementById('perfectBadge');
            if (perfect) {
                perfect.style.display = 'block';
                perfect.classList.add('pop-in');
                setTimeout(() => perfect.classList.remove('pop-in'), 300);
            }

            if (voiceOn) speak('æ‹æ‘„æˆåŠŸï¼');

            setTimeout(() => {
                if (perfect) perfect.style.display = 'none';
            }, 2000);
        }

        // åˆ‡æ¢å‰åæ‘„åƒå¤´
        let currentFacingMode = 'user';
        async function switchCamera() {
            currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';

            const video = document.getElementById('video');
            if (video && video.srcObject) {
                const tracks = video.srcObject.getTracks();
                tracks.forEach(track => track.stop());
            }

            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: currentFacingMode, width: 640, height: 480 }
                });
                video.srcObject = stream;
                await video.play();
                console.log('ğŸ“· åˆ‡æ¢æ‘„åƒå¤´:', currentFacingMode);
            } catch (e) {
                console.error('åˆ‡æ¢æ‘„åƒå¤´å¤±è´¥:', e);
                speak('æ— æ³•åˆ‡æ¢æ‘„åƒå¤´');
            }
        }

        // æ˜¾ç¤ºç›¸å†Œ (æ¨¡æ‹Ÿ)
        function showGallery() {
            const previewImg = document.getElementById('previewImg');
            if (previewImg && previewImg.src) {
                // å¦‚æœæœ‰ç…§ç‰‡ï¼Œå…¨å±æ˜¾ç¤ºï¼ˆæ­¤å¤„ç®€åŒ–é€»è¾‘ï¼‰
                alert('ç›¸å†ŒåŠŸèƒ½å¼€å‘ä¸­... \n(æ­¤å¤„åº”å±•ç¤ºç›¸å†Œé¡µé¢)');
            } else {
                speak('ç›¸å†Œæ˜¯ç©ºçš„');
            }
        }

        // å¼€å§‹å¼•å¯¼ (ç®€åŒ–ç‰ˆï¼Œä»…å¼€å¯ AI)
        function startGuide() {
            if (!inspirationMode) toggleInspirationMode();
        }

        // ===== æ™ºèƒ½å˜ç„¦æ§åˆ¶ =====
        let currentZoom = 1.0;
        let zoomMode = 'unknown'; // 'hardware' | 'css' | 'unknown'
        let videoStream = null; // ä¿å­˜æ‘„åƒå¤´ stream å¼•ç”¨

        /**
         * æ£€æµ‹è®¾å¤‡æ˜¯å¦æ”¯æŒç¡¬ä»¶å˜ç„¦
         */
        async function detectZoomCapability() {
            try {
                const video = document.getElementById('video');
                const stream = video.srcObject;

                if (!stream) {
                    console.warn('âš ï¸ æ— æ³•è·å–è§†é¢‘æµ');
                    return false;
                }

                videoStream = stream;
                const videoTrack = stream.getVideoTracks()[0];

                if (!videoTrack) {
                    console.warn('âš ï¸ æ— æ³•è·å–è§†é¢‘è½¨é“');
                    return false;
                }

                const capabilities = videoTrack.getCapabilities();

                if (capabilities && capabilities.zoom) {
                    console.log('âœ… ç¡¬ä»¶å˜ç„¦æ”¯æŒ:', capabilities.zoom);
                    zoomMode = 'hardware';
                    return true;
                } else {
                    console.log('â„¹ï¸ è®¾å¤‡ä¸æ”¯æŒç¡¬ä»¶å˜ç„¦ï¼Œä½¿ç”¨ CSS å˜ç„¦');
                    zoomMode = 'css';
                    return false;
                }
            } catch (e) {
                console.warn('âš ï¸ å˜ç„¦èƒ½åŠ›æ£€æµ‹å¤±è´¥:', e);
                zoomMode = 'css';
                return false;
            }
        }

        async function setZoom(factor, btn) {
            currentZoom = factor;

            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            if (btn) {
                document.querySelectorAll('.zoom-btn').forEach(b => b.classList.remove('active'));
                btn.classList.add('active');
            }

            const video = document.getElementById('video');
            if (!video) return;

            // å¦‚æœè¿˜æœªæ£€æµ‹å˜ç„¦èƒ½åŠ›ï¼Œå…ˆæ£€æµ‹
            if (zoomMode === 'unknown') {
                await detectZoomCapability();
            }

            // å°è¯•ä½¿ç”¨ç¡¬ä»¶å˜ç„¦
            if (zoomMode === 'hardware' && videoStream) {
                try {
                    const videoTrack = videoStream.getVideoTracks()[0];
                    const capabilities = videoTrack.getCapabilities();

                    const minZoom = capabilities.zoom?.min || 1.0;
                    const maxZoom = capabilities.zoom?.max || 3.0;
                    const targetZoom = Math.min(Math.max(factor, minZoom), maxZoom);

                    await videoTrack.applyConstraints({
                        advanced: [{ zoom: targetZoom }]
                    });

                    console.log(`ğŸ” ç¡¬ä»¶å˜ç„¦: ${targetZoom}x`);
                    video.style.transform = 'scaleX(-1)';

                    if (typeof voiceOn !== 'undefined' && voiceOn) {
                        speak(`å·²æ”¾å¤§${factor}å€`);
                    }
                    return;

                } catch (e) {
                    console.warn('âš ï¸ ç¡¬ä»¶å˜ç„¦å¤±è´¥ï¼Œå›é€€åˆ° CSS:', e);
                    zoomMode = 'css';
                }
            }

            // CSS å˜ç„¦ï¼ˆå›é€€æ–¹æ¡ˆï¼‰
            console.log(`ğŸ” CSS å˜ç„¦: ${factor}x`);
            video.style.transform = `scale(${currentZoom}) scaleX(-1)`;
            video.style.transformOrigin = 'center center';

            if (typeof voiceOn !== 'undefined' && voiceOn) speak(`æ”¾å¤§${factor}å€`);
        }

        // è·å–å˜ç„¦ä¿¡æ¯ï¼ˆè°ƒè¯•ç”¨ï¼‰
        function getZoomInfo() {
            return { mode: zoomMode, currentZoom, hardwareSupported: zoomMode === 'hardware' };
        }

        // åˆ‡æ¢å§¿åŠ¿
        function changePose(id) {
            currentPose = id;
            const p = poses[id];
            const name = p ? p.name : id;

            // æ›´æ–°ä¸‹æ‹‰æ¡†é€‰ä¸­çŠ¶æ€
            const dropdown = document.getElementById('poseDropdown');
            if (dropdown) dropdown.value = id;

            // é‡ç½®åˆ†æ•°
            score = 0;
            highScoreTime = null;

            if (voiceOn) speak(`å·²åˆ‡æ¢åˆ°${name}`);
            console.log('åˆ‡æ¢å§¿åŠ¿:', id);
        }

        // åˆ‡æ¢è¯­éŸ³
        function toggleVoice() {
            voiceOn = !voiceOn;
            speak(voiceOn ? 'è¯­éŸ³å·²å¼€å¯' : 'è¯­éŸ³å·²å…³é—­');
        }

        // ===== æµè§ˆå™¨å…è´¹ TTSï¼ˆWeb Speech APIï¼‰=====
        let webSpeechUtterance = null;  // å½“å‰è¯­éŸ³å¯¹è±¡

        // ä½¿ç”¨é˜¶è·ƒæ˜Ÿè¾° TTS æ’­æ”¾è¯­éŸ³
        let audioCache = new Map();
        let currentAudio = null;
        let ttsPending = null;  // å¾…æ’­æ”¾çš„ä»»åŠ¡

        // ä½¿ç”¨æµè§ˆå™¨ TTSï¼ˆå¿«é€Ÿå“åº”ï¼‰
        function speak(text) {
            if (!voiceOn || !text) return;

            const cleanText = text.trim();
            if (!cleanText) return;

            // åœæ­¢å½“å‰æ’­æ”¾
            if (window.speechSynthesis) {
                window.speechSynthesis.cancel();
            }

            const utterance = new SpeechSynthesisUtterance(cleanText);
            utterance.lang = 'zh-CN';
            utterance.rate = 0.95;
            utterance.pitch = 1.0;

            // é€‰æ‹©ä¸­æ–‡è¯­éŸ³
            const voices = window.speechSynthesis.getVoices();
            const zhVoice = voices.find(v => v.lang.includes('zh')) || voices[0];
            if (zhVoice) utterance.voice = zhVoice;

            window.speechSynthesis.speak(utterance);
            console.log('ğŸ”Š TTS: "%s"', cleanText.substring(0, 20));
        }

        // æ’­æ”¾éŸ³é¢‘
        let audioUnlocked = false;
        function unlockAudio() {
            if (audioUnlocked) return;
            const silent = new Audio('data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=');
            silent.play().then(() => {
                audioUnlocked = true;
                console.log('ğŸ”Š éŸ³é¢‘å·²è§£é”');
            }).catch(e => console.warn('éŸ³é¢‘è§£é”å¤±è´¥:', e));
        }

        function playAudioFromBase64(base64Data) {
            unlockAudio(); // å°è¯•è§£é”

            if (currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
            }

            const audio = new Audio(`data:audio/mp3;base64,${base64Data}`);
            currentAudio = audio;

            audio.onended = () => currentAudio = null;
            audio.onerror = () => {
                currentAudio = null;
                console.warn('æ’­æ”¾å¤±è´¥ï¼Œå°è¯•æµè§ˆå™¨åŸå£°...');
                // å¦‚æœåç«¯æ’­æ”¾å¤±è´¥ï¼Œå›é€€åˆ°æµè§ˆå™¨ TTS
                speakWithWebSpeech(ttsPending || 'æ’­æ”¾å¤±è´¥');
            };

            const playPromise = audio.play();
            if (playPromise !== undefined) {
                playPromise.catch(e => {
                    console.warn('æ’­æ”¾è¢«æµè§ˆå™¨æ‹¦æˆª:', e);
                    // å¦‚æœè¢«æ‹¦æˆªï¼Œå¼•å¯¼ç”¨æˆ·ç‚¹å‡»æˆ–å›é€€
                    speakWithWebSpeech(ttsPending || 'è¯­éŸ³å·²å°±ç»ª');
                });
            }
        }

        // æµè§ˆå™¨å†…ç½® TTS å›é€€
        function speakWithWebSpeech(text) {
            if (!voiceOn || !text) return;
            try {
                window.speechSynthesis.cancel();
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'zh-CN';
                utterance.rate = 1.0;
                window.speechSynthesis.speak(utterance);
            } catch (e) {
                console.error('Web Speech Error:', e);
            }
        }

        // åœæ­¢ TTS
        function stopTTS() {
            ttsPending = null;
            if (currentAudio) {
                currentAudio.pause();
                currentAudio.currentTime = 0;
                currentAudio = null;
            }
            console.log('ğŸ›‘ TTS å·²åœæ­¢');
        }

        // ===== AI æ™ºèƒ½åˆ†æ =====

        // é¿å…é‡å¤æ’­æŠ¥ç›¸åŒå†…å®¹
        let lastSpokenText = '';

        // æ·»åŠ  AI åˆ†ææŒ‰é’®åŠŸèƒ½
        function triggerAIAnalysis() {
            lastAnalysisTime = 0;  // é‡ç½®æ—¶é—´ï¼Œç«‹å³åˆ†æ
            analyzeCurrentFrame();
        }

        window.onload = function () {
            try {
                init();
            } catch (e) {
                console.error('Init error:', e);
            }
        };

        // å¤‡ç”¨æ–¹æ¡ˆï¼š5ç§’åå¼ºåˆ¶éšè— loading
        setTimeout(() => {
            const loading = document.getElementById('loading');
            if (loading) {
                loading.style.display = 'none';
            }
            const feedback = document.getElementById('feedback');
            if (feedback) {
                feedback.textContent = 'ç‚¹å‡» âœ¨ å¼€å¯æ™ºèƒ½æ‹ç…§';
            }
        }, 5000);
    </script>
</body>

</html>